<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>/비트/외래 통계 자동 계산 도구</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1000px; margin: auto; }
    h1 { color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; overflow-x: auto; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; vertical-align: middle; }
    th { background-color: #f4f4f4; }
    .warn { color: red; font-weight: bold; margin-top: 10px; }
    .input-section { margin: 20px 0; }
    tbody tr.whole { background-color: #eaf2f8; }
    tbody tr.room1 { background-color: #fef9e7; }
    tbody tr.room2 { background-color: #e8f8f5; }
    tbody tr.room3 { background-color: #fbeee6; }
    tbody tr.room4 { background-color: #f9ebea; }
    tbody tr.room5 { background-color: #f5eef8; }
  </style>
</head>
<body>
  <h1>/비트/외래 통계 자동 계산기</h1>
  <div class="input-section">
    <label>✔️ 특정 키워드(예: PT만)를 입력하세요:</label><br>
    <input type="text" id="keywordInput" placeholder="예: PT만" style="width: 200px; margin-top: 5px;" />
  </div>
  <input type="file" id="fileInput" accept=".xlsx,.csv" />
  <div id="output"></div>
  <div id="warning" class="warn"></div>

  <script>
    function getAgeFromSA(sa) {
      const match = sa.match(/\/(\d{1,2})\uC138/);
      return match ? parseInt(match[1]) : null;
    }

    function getAgeGroup(age) {
      if (isNaN(age)) return "미확인";
      if (age <= 19) return "0~10대";
      if (age <= 29) return "20대";
      if (age <= 39) return "30대";
      if (age <= 49) return "40대";
      if (age <= 64) return "50대~64세";
      return "65세이상";
    }

    function process(rawData, keyword) {
      const headerRowIndex = rawData.findIndex(row => row.join('').includes("초/재"));
      if (headerRowIndex === -1) {
        document.getElementById('warning').innerText = '❗ 유효한 열 이름을 찾을 수 없습니다.';
        return;
      }

      const headers = rawData[headerRowIndex].map(h => h.toString().trim());
      const dataRows = rawData.slice(headerRowIndex + 1).filter(r => r.length > 1);
      const df = dataRows.map(row => {
        let obj = {};
        headers.forEach((col, i) => { obj[col] = row[i] || ""; });
        return obj;
      });

      const col = name => headers.find(h => h.includes(name)) || "";
      const colMap = {
        sa: col("S/A"),
        chojae: col("초/재"),
        chart: col("챠트번호"),
        dept: col("진료과"),
        memo: col("접수메모"),
        anesthesia: col("마취")
      };

      const reVisitCodes = ["재진", "물리치료내원", "진찰료 산정안함"];
      const rooms = [...new Set(df.map(r => r[colMap.dept] || "기타"))];

      function groupStats(records, name) {
        const sub = records;
        const newPts = sub.filter(r => ["신환", "90일초진"].includes(r[colMap.chojae]));
        const chartSet = [...new Set(newPts.map(r => r[colMap.chart]))];
        const injNewPts = newPts.filter(r => (r[colMap.anesthesia] || '').includes('●'));
        const injCharts = [...new Set(injNewPts.map(r => r[colMap.chart]))];
        const allVisits = sub.length;

        const injVisits = sub.filter(r => injCharts.includes(r[colMap.chart]));
        const injCount = {}, visitCount = {};
        injVisits.forEach(r => {
          const id = r[colMap.chart];
          if ((r[colMap.anesthesia] || '').includes('●')) injCount[id] = (injCount[id] || 0) + 1;
          visitCount[id] = (visitCount[id] || 0) + 1;
        });

        const avgInj = Object.values(injCount).length ? (Object.values(injCount).reduce((a, b) => a + b) / Object.keys(injCount).length).toFixed(1) : 0;
        const avgVisitInj = Object.values(visitCount).length ? (Object.values(visitCount).reduce((a, b) => a + b) / Object.keys(visitCount).length).toFixed(1) : 0;

        const totalNewRecords = sub.filter(r => chartSet.includes(r[colMap.chart]));
        const newVisitCounts = {};
        totalNewRecords.forEach(r => {
          const id = r[colMap.chart];
          newVisitCounts[id] = (newVisitCounts[id] || 0) + 1;
        });

        const newAvgVisit = Object.values(newVisitCounts).length ? (Object.values(newVisitCounts).reduce((a, b) => a + b) / Object.keys(newVisitCounts).length).toFixed(1) : 0;
        const reVisitRatio = Object.values(newVisitCounts).filter(v => v >= 2).length / Object.keys(newVisitCounts).length * 100;
        const memoCount = keyword ? sub.filter(r => (r[colMap.memo] || '').toLowerCase().includes(keyword)).length : "";

        const visitRatio = n => Math.round(Object.values(newVisitCounts).filter(v => v === n).length / Object.keys(newVisitCounts).length * 100);
        const over5 = Math.round(Object.values(newVisitCounts).filter(v => v >= 5).length / Object.keys(newVisitCounts).length * 100);

        return {
          group: name.includes("/") ? name.split(" / ")[0] : name,
          sub: name.includes("/") ? name.split(" / ")[1] : "전체",
          ...{
            "초진환자수": chartSet.length,
            "재진환자수": sub.filter(r => reVisitCodes.includes(r[colMap.chojae])).length,
            "총환자수": allVisits,
            "초진 주사 처방률": chartSet.length ? Math.round((injNewPts.length / chartSet.length) * 100) + "%" : "0%",
            "초진주사 갯수": injNewPts.length,
            "초진 주사환자 재진율": visitCount && Object.keys(visitCount).length ? Math.round((Object.values(visitCount).filter(v => v >= 2).length / Object.keys(visitCount).length) * 100) + "%" : "0%",
            "초진주사환자 평균 주사횟수": avgInj,
            "초진 주사환자 평균내원횟수": avgVisitInj,
            "초진평균내원횟수": newAvgVisit,
            "초진 재내원율": Math.round(reVisitRatio) + "%",
            "1회 내원 비율": visitRatio(1) + "%",
            "2회 내원 비율": visitRatio(2) + "%",
            "3회 내원 비율": visitRatio(3) + "%",
            "4회 내원 비율": visitRatio(4) + "%",
            "5회 이상 내원 비율": over5 + "%",
            "특정 키워드 포함 메모 수": memoCount
          }
        };
      }

      let result = [];
      result.push(groupStats(df, "전체"));
      const allAgeGroups = {};
      df.forEach(r => {
        const age = getAgeFromSA(r[colMap.sa]);
        const group = getAgeGroup(age);
        if (!allAgeGroups[group]) allAgeGroups[group] = [];
        allAgeGroups[group].push(r);
      });
      Object.entries(allAgeGroups).forEach(([groupName, rows]) => {
        result.push(groupStats(rows, `전체 / ${groupName}`));
      });

      rooms.forEach(room => {
        const filtered = df.filter(r => r[colMap.dept] === room);
        result.push(groupStats(filtered, room));

        const ageGroups = {};
        filtered.forEach(r => {
          const age = getAgeFromSA(r[colMap.sa]);
          const group = getAgeGroup(age);
          if (!ageGroups[group]) ageGroups[group] = [];
          ageGroups[group].push(r);
        });

        Object.entries(ageGroups).forEach(([groupName, rows]) => {
          result.push(groupStats(rows, `${room} / ${groupName}`));
        });
      });

      const keys = Object.keys(result[0]).filter(k => !["group", "sub"]);
      let html = '<table><thead><tr><th>구분</th><th>연령대</th>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr></thead><tbody>';

      const grouped = {};
      result.forEach(row => {
        const g = row.group;
        if (!grouped[g]) grouped[g] = [];
        grouped[g].push(row);
      });

      Object.entries(grouped).forEach(([group, rows]) => {
        rows.forEach((row, idx) => {
          const className = group.startsWith("전체") ? "whole" : group.includes("1진") ? "room1" : group.includes("2진") ? "room2" : group.includes("3진") ? "room3" : group.includes("4진") ? "room4" : group.includes("5진") ? "room5" : "";
          html += `<tr class="${className}">`;
          if (idx === 0) {
            html += `<td rowspan="${rows.length}">${group}</td>`;
          }
          html += `<td>${row.sub}</td>`;
          html += keys.map(k => `<td>${row[k]}</td>`).join('');
          html += '</tr>';
        });
      });
      html += '</tbody></table>';
      document.getElementById('output').innerHTML = html;
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      const keyword = document.getElementById('keywordInput').value.trim().toLowerCase();
      const reader = new FileReader();
      const isCSV = file.name.endsWith('.csv');

      reader.onload = function(e) {
        let rawData = [];
        if (isCSV) {
          const csv = e.target.result;
          const rows = csv.split(/\r?\n/).map(row => row.split(','));
          rawData = rows;
          process(rawData, keyword);
        } else {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          workbook.SheetNames.forEach(sheet => {
            const sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheet], { header: 1, defval: "" });
            rawData = rawData.concat(sheetData);
          });
          process(rawData, keyword);
        }
      };
      if (isCSV) reader.readAsText(file);
      else reader.readAsArrayBuffer(file);
    });
  </script>
</body>
</html>
