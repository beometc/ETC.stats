<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>/비트/외래 통계 자동 계산 도구</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1000px; margin: auto; }
    h1 { color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; overflow-x: auto; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background-color: #f4f4f4; }
    .warn { color: red; font-weight: bold; margin-top: 10px; }
    .input-section { margin: 20px 0; }
  </style>
</head>
<body>
  <h1>/비트/외래 통계 자동 계산기</h1>

  <div class="input-section">
    <label>✔️ 특정 키워드(예: PT만)를 입력하세요:</label><br>
    <input type="text" id="keywordInput" placeholder="예: PT만" style="width: 200px; margin-top: 5px;" />
  </div>

  <input type="file" id="fileInput" accept=".xlsx,.csv" />
  <div id="output"></div>
  <div id="warning" class="warn"></div>

  <script>
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      const keyword = document.getElementById('keywordInput').value.trim().toLowerCase();
      const reader = new FileReader();
      const isCSV = file.name.endsWith('.csv');

      reader.onload = function(e) {
        let rawData = [];
        if (isCSV) {
          const csv = e.target.result;
          const rows = csv.split(/\r?\n/).map(row => row.split(','));
          rawData = rows;
          process(rawData, keyword);
        } else {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          workbook.SheetNames.forEach(sheet => {
            const sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheet], { header: 1, defval: "" });
            rawData = rawData.concat(sheetData);
          });
          process(rawData, keyword);
        }
      };
      if (isCSV) reader.readAsText(file);
      else reader.readAsArrayBuffer(file);
    });

    function getAgeGroup(ageStr) {
      const match = String(ageStr).match(/(\d{1,3})\s*\uC138/); // "세" 문자를 포함한 숫자 추출
      let age = match ? parseInt(match[1]) : parseInt(ageStr);
      if (isNaN(age)) return "미확인";
      if (age <= 19) return "0~10대";
      if (age <= 29) return "20대";
      if (age <= 39) return "30대";
      if (age <= 49) return "40대";
      if (age <= 64) return "50대~64세";
      return "65세이상";
    }

    function process(rawData, keyword) {
      const headerRowIndex = rawData.findIndex(row => row.join('').includes("초/재") || row.join('').includes("챠트번호") || row.join('').includes("진료과") || row.join('').includes("마취"));
      if (headerRowIndex === -1) {
        document.getElementById('warning').innerText = '❗ 유효한 열 이름을 찾을 수 없습니다.';
        return;
      }

      const headers = rawData[headerRowIndex].map(h => h.toString().trim());
      const dataRows = rawData.slice(headerRowIndex + 1).filter(r => r.length > 1);
      const df = dataRows.map(row => {
        let obj = {};
        headers.forEach((col, i) => { obj[col] = row[i] || ""; });
        return obj;
      });

      const headerMap = {};
      headers.forEach(h => {
        const lname = h.toLowerCase();
        if (lname.includes("초") && lname.includes("재")) headerMap['초재'] = h;
        else if (lname.includes("차트") || lname.includes("챠트") || lname.includes("환자") || lname.includes("id")) headerMap['챠트번호'] = h;
        else if (lname.includes("마취")) headerMap['마취'] = h;
        else if ((lname.includes("진료") && lname.includes("과")) || lname.includes("과목")) headerMap['진료과'] = h;
        else if (lname.includes("메모")) headerMap['접수메모'] = h;
        else if (lname.includes("나이") || lname.includes("연령") || lname.includes("생년")) headerMap['연령'] = h;
      });

      // S/A에서 연령 정보 추출 보완
      if (!headerMap['연령']) {
        const saHeader = headers.find(h => h.toLowerCase().includes("s/a") || h.toLowerCase().includes("sa"));
        if (saHeader) headerMap['연령'] = saHeader;
      }

      const 필수 = ['초재', '챠트번호', '마취', '진료과'];
      const 누락 = 필수.filter(k => !headerMap[k]);
      if (누락.length) {
        document.getElementById('warning').innerText = `❗ 필수 열 누락: ${누락.join(', ')}`;
        return;
      }

      const 재진조건 = ["재진", "물리치료내원", "진찰료 산정안함"];
      const 진료실목록 = [...new Set(df.map(r => r[headerMap['진료과']] || '기타'))];
      const 연령정보 = !!headerMap['연령'];

      function countStats(data, 구분명) {
        // ... 동일 생략 (기존 countStats 함수 그대로 유지) ...
      }

      let 통계 = [];
      const 구분대상 = [{ label: "전체", data: df }]
        .concat(
          진료실목록.map(진료과 => ({
            label: 진료과,
            data: df.filter(r => (r[headerMap['진료과']] || '기타') === 진료과)
          }))
        );

      구분대상.forEach(대상 => {
        const baseLabel = 대상.label;
        const baseData = 대상.data;

        통계.push(countStats(baseData, baseLabel));

        if (연령정보) {
          const 연령대목록 = [...new Set(baseData.map(r => getAgeGroup(r[headerMap['연령']])))]
          연령대목록.forEach(연령대 => {
            const 그룹 = baseData.filter(r => getAgeGroup(r[headerMap['연령']]) === 연령대);
            통계.push(countStats(그룹, `${baseLabel} / ${연령대}`));
          });
        }
      });

      const keys = Object.keys(통계[0]);
      let html = '<table><thead><tr>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr></thead><tbody>';
      통계.forEach(row => {
        html += '<tr>' + keys.map(k => `<td>${row[k]}</td>`).join('') + '</tr>';
      });
      html += '</tbody></table>';
      document.getElementById('output').innerHTML = html;
    }
  </script>
</body>
</html>
